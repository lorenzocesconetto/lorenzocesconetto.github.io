<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lorenzo Cesconetto">
<meta name="dcterms.date" content="2025-09-16">

<title>Rotary Position Embedding (RoPE) ‚Äì Lorenzo Cesconetto</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-befe23ebd2f54d8af2c8a89d1a1611f1.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-ec7ccfbb941a833fdbb8fb4bea212431.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-a3a3163c528fce66c8cbb601af61b2ca.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-dark"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = true;
    const queryPrefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    const darkModeDefault = queryPrefersDark.matches;
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    queryPrefersDark.addEventListener("change", e => {
      if(window.localStorage.getItem("quarto-color-scheme") !== null)
        return;
      const alternate = e.matches
      toggleColorMode(alternate);
      localAlternateSentinel = e.matches ? 'alternate' : 'default'; // this is used alongside local storage!
      toggleGiscusIfUsed(alternate, darkModeDefault);
    });
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Lorenzo Cesconetto</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/lorenzo-cesconetto/" target="_blank"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/l_cesconetto" target="_blank"> <i class="bi bi-twitter-x" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/lorenzocesconetto" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Rotary Position Embedding (RoPE)</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Transformers</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Lorenzo Cesconetto </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 16, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="intro" class="level1">
<h1>Intro</h1>
<p>There are plenty of good resources on understanding the transformers architecture out there in the internet. But <strong>Rotary Position Embedding</strong> (introduced by this <a href="https://arxiv.org/pdf/2104.09864">paper</a>) is the one piece often poorly explained or not explained at all.</p>
<p>The mathematical operations are rather simple, it‚Äôs mainly matrix multiplications. The hard part is understanding the intuition around it, visualizing what it‚Äôs doing to vectors, and understanding why it works. Well, that‚Äôs what I‚Äôll attempt to provide you with.</p>
<p><em>I expect you have basic understanding of transformers and attention mechanism throughout this post.</em></p>
</section>
<section id="rope-intuition" class="level1">
<h1>RoPE Intuition</h1>
<p>Since transformers don‚Äôt have a sense of order and distances, researchers came up with positional embeddings. Here‚Äôs what positional embeddings should aim to accomplish:</p>
<ul>
<li><p>Tokens closer to each other attend with more higher weight. While tokens far from each other attend with lower weights.</p></li>
<li><p>It doesn‚Äôt matter whether two words are in the beginning or end of a long sequence, if they‚Äôre close to each other, they should (more likely) <strong>attend</strong> each other with higher weights.</p></li>
<li><p>To accomplish the previous constraints, <strong>relative positional embeddings</strong> are much more useful than absolute positions embeddings.</p></li>
</ul>
<p><strong>Conclusion</strong>: LLMs should focus on relative positions, which is what really matters.</p>
<p>If you understand these concepts, you‚Äôre already half way there.</p>
</section>
<section id="before-rope" class="level1">
<h1>Before RoPE</h1>
<p>The original positional embeddings introduced by <em><a href="https://arxiv.org/pdf/1706.03762">Attention is all you need</a></em> were a pre-defined values (defined by a formula) added with the semantics (meaning) embeddings. The formula made sense, and RoPE does something similar, but mixing semantics and position was very confusing, not only for humans, but for the LLM as well. As it turns out, later research did confirm LLMs were memorizing (overfitting) rather than generalizing the positions, and those LLMs would quickly deteriorate as the sequence length would increase beyond sequences in their training dataset.</p>
<p>One strategy that has shown to be a winning strategy in the early years of Deep Learning: whenever we‚Äôre unsure about how to compute useful features for a Neural Network (NN), just let the NN learn by itself! üòù That‚Äôs what LLMs like GPT-3 did, let the LLM learn its own position embeddings. As it turns out, providing too much freedom for NNs increases overfitting risks, and in this case, also poses a hard limit in the context window.</p>
<p>The best efforts would focus on modifying the attention mechanism. Tokens closer to each other will have a higher attention weight, meanwhile tokens far will have a lower weight. So the goal was to modify <span class="math inline">\(Q\)</span> and <span class="math inline">\(K\)</span> in a clever way so the dot products would reflect closeness, while preserving the hidden states.</p>
</section>
<section id="rotation-intuition" class="level1">
<h1>Rotation Intuition</h1>
<p>RoPE modifies <span class="math inline">\(Q\)</span> and <span class="math inline">\(K\)</span> by applying a rotation to them.</p>
<p>Let <span class="math inline">\(q\)</span> be the query projection of a token and <span class="math inline">\(k\)</span> the key projection of another. If the tokens that are close in the text, little rotation will be applied, while distant tokens suffer larger rotation transformation.</p>
<p>Imagine two identical projection vectors, any rotation applied would make those two vectors more far a part! That‚Äôs exactly what we want.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./rope_basic_rotation.gif" class="img-fluid figure-img"></p>
<figcaption>RoPE Basic Rotation Animation</figcaption>
</figure>
</div>
<p>Now, this other situation can be confusing: if the two projection vectors are far from each other, the rotation might make them closer! That‚Äôs <strong>NOT</strong> what we want üò±. They‚Äôre being rotated because they‚Äôre far from each other in the text, so they shouldn‚Äôt receive a high attendance weight. Why does it work then?</p>
<ul>
<li><p>In 2D, there‚Äôs only one rotation axis, which is <span class="math inline">\(z\)</span>. You can only rotate either clock-wise or counter clock-wise</p></li>
<li><p>In 3D there‚Äôs literally an infinite number of rotation axis. There‚Äôs a very low probability that the rotation will make the two vectors get closer to each other.</p></li>
<li><p>Modern models usually operate in a very high dimensional space (+10k dimensions), making this even more unlikely.</p></li>
</ul>
<iframe src="./rope_3d_interactive.html" width="820" height="620" frameborder="0">
</iframe>
<p><strong>Remember, in Deep Learning, probabilities is what really matters! So it‚Äôs okay to be wrong, as long as the probabilities are low :)</strong></p>
</section>
<section id="angle-of-rotation" class="level1">
<h1>Angle of rotation</h1>
<p>The angle of rotation depends on two factors: <span class="math inline">\(m\)</span> and <span class="math inline">\(i\)</span>. Let‚Äôs dive into each of them.</p>
<section id="token-absolute-position-m" class="level3">
<h3 class="anchored" data-anchor-id="token-absolute-position-m">Token absolute position <span class="math inline">\(m\)</span></h3>
<p>The rotation increases as the token‚Äôs absolute position <span class="math inline">\(m\)</span> increases.</p>
<p>Okay, I know what you‚Äôre thinking: <span class="math inline">\(m\)</span> is absolute position we shouldn‚Äôt use it since I said relative positions is what really matters‚Ä¶</p>
<p>Well, here‚Äôs the magic, think about a 2D plane, when you rotate one vector by <span class="math inline">\(\alpha\)</span> and a second vector by <span class="math inline">\(\beta\)</span>, the delta in the angle between them is <span class="math inline">\(\alpha - \beta\)</span>. It doesn‚Äôt matter their absolute values, what matters is their differences. So for two tokens with positions <span class="math inline">\(m\)</span> and <span class="math inline">\(n\)</span>, the rotation applied will modify the angle between them proportional to <span class="math inline">\(m-n\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="rope_rotation_visualization.png" class="img-fluid figure-img"></p>
<figcaption>Relative distance after rotation</figcaption>
</figure>
</div>
<blockquote class="blockquote">
<p>Let‚Äôs forget that <span class="math inline">\(k\)</span> gets rotate and let‚Äôs assume we‚Äôre always rotating <span class="math inline">\(q\)</span> only (it‚Äôs mathematically accurate since we‚Äôre not concerned about the final coordinates, but rather their final distances).</p>
</blockquote>
</section>
<section id="hidden-state-index-i" class="level3">
<h3 class="anchored" data-anchor-id="hidden-state-index-i">Hidden state index <span class="math inline">\(i\)</span></h3>
<p>Instead of applying the same rotation across all dimensions of the hidden state, RoPE picks two dimensions at a time, and applies its own rotation angle. Put in another words, it‚Äôs breaking the long vector into multiple pairs that can be 2D rotated bu different angles.</p>
<p>Essentially, we rotate the hidden state dimensions differently. It‚Äôs higher when <span class="math inline">\(i\)</span> is low (the beginning of the vector) and it‚Äôs lower when <span class="math inline">\(i\)</span> is high (towards the end of the vector).</p>
<p>Understanding this operation is easy, understanding why we need it is a bit more involved. Here‚Äôs the explanation:</p>
<ul>
<li>It makes it easier for the model to choose what should have <strong>shorter or longer range of influence</strong>.
<ul>
<li>Imagine vectors in 3D (<span class="math inline">\(xyz\)</span>).</li>
<li>The <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> axis represent early dimensions (<span class="math inline">\(i\)</span> is low) that suffer higher rotation. This means that tokens mainly projected in <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> there should to be very close to each other in order to attend with more intensity.</li>
<li>The <span class="math inline">\(z\)</span> axis, where <span class="math inline">\(i\)</span> is lower, rotates less. Tokens projected mainly in <span class="math inline">\(z\)</span> should attend even when they‚Äôre distant.</li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./rope_high_xy_rotation_1.gif" class="img-fluid figure-img"></p>
<figcaption>We apply a rotation on the <span class="math inline">\(xy\)</span> plane. Two vectors that encode information mainly in <span class="math inline">\(z\)</span> will remain very close despite the rotation (a pair of tokens that should be attended despite longer distances!)</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./rope_high_xy_rotation_2.gif" class="img-fluid figure-img"></p>
<figcaption>Two vectors that encode information in <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> instead, will become very far apart (tokens are close but one should not attend the other).</figcaption>
</figure>
</div>
<p>This structure is able to capture complicated nuances in human language, really cool, huh!?</p>
<p>Okay, I know what you‚Äôre thinking, after you rotate too much they start getting close to each other again. That‚Äôs right, but here‚Äôs why it still works:</p>
<ol type="1">
<li>We‚Äôre only working with 3 dimensions for this visualization, but in reality, this happens in a much higher dimension.</li>
<li>Although some dimensions start getting closer, the others that rotate slower are still getting farther apart.</li>
<li>RoPE is <strong>not</strong> perfect, because of this rotating nature, there are some local maximas happening! Look at the chart provided by the author</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./RoPE-decay.png" class="img-fluid figure-img"></p>
<figcaption>Source: ROFORMER: ENHANCED TRANSFORMER WITH ROTARY POSITION EMBEDDING</figcaption>
</figure>
</div>
<p>An idea that occurred to me would be to clip the rotation angle, I wonder if any newer papers have tried this already ü§î.</p>
<blockquote class="blockquote">
<p><strong>In the end of the day the LLM learns to encode long-ranging meaning influence and short-range meaning influence in the different dimensions of the hidden state.</strong></p>
</blockquote>
<p>To make it concrete, let me provide a few examples:</p>
<ul>
<li>The LLM is fed a python code. In the beginning, it applies some transformation to some dataframe <code>df</code>. Well, that‚Äôs relevant information that should be possibly be carried over a long range.</li>
<li>Adjectives tend to characterize nouns that are <strong>very close</strong>. ‚ÄúA beautiful girl playing video-game‚Äù. In this example the word <code>beautiful</code> should mainly affect the <code>girl</code> embedding.</li>
</ul>
</section>
</section>
<section id="the-angle-formula" class="level1">
<h1>The angle formula</h1>
<p>Now that you understand all the concepts and have gained a strong intuition of things it‚Äôs okay to throw some equations here. The angle of rotation is defined by <span class="math inline">\(m\times \theta\)</span>, where <span class="math inline">\(m\)</span> is the token‚Äôs absolute position in the text and theta is <span class="math inline">\(\theta=\text{10,000} ^ {-2(i-1)/d_{model}}\)</span>, with <span class="math inline">\(i \in \{1, 2,... d/2\}\)</span> being the dimensions of the hidden state.</p>
<p>When <span class="math inline">\(i=1 \Rightarrow \theta=1\)</span> (high) and when <span class="math inline">\(i=d/2 \Rightarrow \theta \approx 1/10,000\)</span> (low).</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<ul>
<li>We should find clever ways to inject knowledge to the LLM, instead of letting it learn all by itself
<ul>
<li>We do that by providing just the right operations a NN needs to process data, attention and convolutions are a great examples of this</li>
</ul></li>
<li>Closed equation can be extended indefinitely, since you don‚Äôt have to learn each position embedding
<ul>
<li>That‚Äôs why RoPE provides great flexibility of sequence length</li>
</ul></li>
<li>The most important property: attention weights decreases as relative distances increase.
<ul>
<li>It‚Äôs basically the same intuition behind local attention in the alternating attention architecture.</li>
</ul></li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2025, Lorenzo Cesconetto</p>
</div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/lorenzo-cesconetto/" target="_blank">
      <i class="bi bi-linkedin" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://x.com/l_cesconetto" target="_blank">
      <i class="bi bi-twitter-x" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/lorenzocesconetto" target="_blank">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>